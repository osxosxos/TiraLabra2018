import java.util.ArrayDeque;
import java.util.Random;
import java.util.Scanner;
import java.util.Stack;

// lauta-taulu pitää yllä pelitilanteen
// pisteytys-taulu pitää huolen, että jokainen ruutu pisteytetään vain kerran
public class Peli {
    private int [][]lauta;
    private boolean[][]pisteytys;
    private Stack<Integer>laatat;
    private int seuraajat;
    private int koko;
    private int pisteet;
    
    public Peli(int koko) {
        this.lauta = new int[koko][koko];
        this.pisteytys = new boolean[koko][koko];        
        this.laatat = new Stack();
        this.seuraajat = 9;
        this.koko = koko;
        this.pisteet = 0;
    }
    
    // Sekoittaa pakan uutta peliä varten
    public void taytaPakka(int koko) {
        Random random = new Random();
        for (int i = 0; i < koko; i++) {
            int pala = random.nextInt(2);
            if (pala == 0) laatat.push(1);
            if (pala == 1) laatat.push(2);
        }
    }
       
    // Tarkistaa, että ruutu ei ole ruudukon ulkopuolella
    public boolean voikoMenna(int rivi, int sarake) {
        if (rivi < 0 || rivi >= koko) return false;
        return !(sarake < 0 || sarake >= koko);
    }
    
    // Tarkistaa, että ruutu on tyhjä
    public boolean onkoVapaa(int rivi, int sarake) {
        return this.lauta[rivi][sarake] == 0;
    }
    
    // Asettaa laatan kartalle 
    public void asetaLaatta(int rivi, int sarake, int laatta) {
        this.lauta[rivi][sarake] = laatta;
    }
    
    // Metodi asettaa kartalle pelaajan numeroa vastaavan seuraajan
    // Tässä versiossa pelaajia on vain yksi ja numeronsa on kolme
    public void asetaSeuraaja(int rivi, int sarake, int pelaaja) {
        this.lauta[rivi][sarake] = pelaaja;
    }
    
    // Metodi tulostaa kartan
    public void tulostaKartta() {
        for (int i = 0; i < lauta.length;i++) { 
            for (int j = 0; j < lauta.length;j++) { 
                System.out.print(lauta[i][j]);   
            }
            System.out.println();
        }        
    }
        
    // Pelin käyttöliittymä, koodin pitäisi selittää itse itseään IMO
    public void pelaa() {        
        System.out.println("--------tervetuloa pelaamaan!----------");
        System.out.println("peli jatkuu niin kauan kuin laattoja on");
        System.out.println("---------------------------------------");
        System.out.println("");
        Scanner scanner = new Scanner(System.in);
                
        while(!laatat.empty()) {
            System.out.println("sinulla on nyt pisteitä: " + this.pisteet);
            System.out.println("laattoja on jäljellä: " + laatat.size());
            System.out.println("kartta on nyt:");
            tulostaKartta();
            int seuraava = laatat.pop();
            if (seuraava == 1) {
                System.out.println("laatta on pelto");
                while(true) {
                    System.out.println("anna rivi:");
                    int rivi = Integer.parseInt(scanner.nextLine());
                    System.out.println("anna sarake:");
                    int sarake = Integer.parseInt(scanner.nextLine());
                    if (voikoMenna(rivi,sarake) && onkoVapaa(rivi,sarake)) {
                        asetaLaatta(rivi,sarake,1);
                        // Jos peloruudun vieressä on yksi tai useampi linna
                        // Tarkistetaan, tuleeko yksi tai useampi näistä valmiiksi
                        int[]rivit = new int[]{1,0,-1,0};
                        int[]sarak = new int[]{0,1,0,-1};
                        for (int i = 0; i < rivit.length; i++) {
                            int uusiRivi = rivi + rivit[0];
                            int uusiSara = sarake + sarak[0];
                            if (voikoMenna(uusiRivi,uusiSara)) {
                                if (lauta[uusiRivi][uusiSara] == 2) {
                                    if (onValmis(uusiRivi,uusiSara)) {
                                        this.pisteet = this.pisteet + linnanPisteet(uusiRivi,uusiSara);
                                    }
                                }
                                if (lauta[uusiRivi][uusiSara] == 3) {
                                    if (onValmis(uusiRivi,uusiSara)) {
                                        this.pisteet = this.pisteet + linnanPisteet(uusiRivi,uusiSara);
                                    }
                                }
                            }                           
                        }                        
                        break;
                    } else {
                        System.out.println("epäkelpo ruutu!");
                    }                
                }                                
            } else {
                System.out.println("laatta on linna");
                while(true) {
                    System.out.println("anna rivi:");
                    int rivi = Integer.parseInt(scanner.nextLine());
                    System.out.println("anna sarake:");
                    int sarake = Integer.parseInt(scanner.nextLine());
                    if (voikoMenna(rivi,sarake) && onkoVapaa(rivi,sarake)) {
                        asetaLaatta(rivi,sarake,2);
                        System.out.println("haluatko asettaa seuraajan");
                        System.out.println("1 = kyllä, 2 = ei");
                        int vastaus = Integer.parseInt(scanner.nextLine());
                        if (vastaus == 1) {
                            if (!onkoLinnassaJoSeuraaja(rivi,sarake)) {
                                asetaSeuraaja(rivi,sarake,3);
                                System.out.println("seuraajan asettaminen onnistui");
                                if (onValmis(rivi,sarake)) {
                                    this.pisteet = this.pisteet + linnanPisteet(rivi,sarake);
                                }
                                break;
                            } else {
                                System.out.println("linnassa on jo seuraaja");
                                if (onValmis(rivi,sarake)) {
                                    this.pisteet = this.pisteet + linnanPisteet(rivi,sarake);
                                }
                                break;
                            }
                        } else {
                            if (onValmis(rivi,sarake)) {
                                this.pisteet = this.pisteet + linnanPisteet(rivi,sarake);
                            }
                            break;
                        }
                    } else {
                        System.out.println("epäkelpo ruutu!");
                    }                    
                }
            }
        }
        this.pisteet = laskePisteet();
        System.out.println("Peli on nyt loppu.");
        System.out.println("sait " + this.pisteet + " pistettä!");
    }
    
    // Seuraajaa ei voi asettaa linnaan, jossa on jo seuraaja.
    // Funktio tarkistaa, että linnassa ei ole kenenkään pelaajan seuraajia.
    // Rivi ja sarake kertovat äsken sijoitutun linnaruudun sijainnin. 
    // Metodi käy linnan läpi leveyssuuntaisella haulla.
    // Metodi lopettaa kun seuraaja löytyy
    public boolean onkoLinnassaJoSeuraaja (int rivi, int sarake) {
        // Käsittelemättömät linna ruudut ovat jonossa
        // Jonossa on aluksi vain funktiolle parametrinä annettu lähtöruutu
        ArrayDeque<int[]>jono = new ArrayDeque();
        int[]eka = new int[]{rivi,sarake};
        jono.add(eka);
        
        // Näillä taulukoilla algoritmi navigoi viereisiin ruutuihin
        int[]rivit = new int[]{1,0,-1,0};
        int[]sarak = new int[]{0,1,0,-1};
        
        // Käydään jonossa olevat alkiot läpi yksi kerrallaan
        while (!jono.isEmpty()) {
            int[]edellinen = jono.poll();
            for (int i = 0; i < rivit.length; i++) {
                // lasketaan uudet kordinaatit ylos, alas, vasen ja oikea
                int rivi2 = edellinen[0] + rivit[i];
                int sara2 = edellinen[1] + sarak[i];
                if (voikoMenna(rivi2,sara2)) {
                    // Kun seuraaja löytyy palautetaan true
                    if (lauta[rivi2][sara2] == 3) {
                        return true;
                    } else if (lauta[rivi2][sara2] == 2) {
                        int[]uusi = new int[]{rivi2,sara2};
                        jono.add(uusi);
                    }
                }
            }
        }     
        // Kun koko linna on käyty läpi ja seuraajaa ei ole löytynyt
        // Voidaan todeta, että linnassa ei ole seuraajaa
        return false;
    }    
    
    // Apumetodi, joka laskee yksittäisen linnan pisteet
    // Linnan omistaja saa pisteitä yhden jokaista ruutua kohden
    // Funktio saa parametrikseen linnan lähtöpisteen ruudukossa
    // Funktio merkitsee pisteytys tauluun jokaisen linna ruudun, 
    // joka kuuluu samaan linnaan käsitellyksi
    // Tämä metodi soveltaa verkon leveyssuuntaista hakua
    public int linnanPisteet(int rivi, int sarake) {
        int pisteet = 0;
        
        // Käsittelemättömät ruudut ovat tässä jonossa
        ArrayDeque<int[]>jono = new ArrayDeque();
        int[]eka = new int[]{rivi,sarake};
        jono.add(eka);
        
        // Aputaulukko, jolla algoritmi navigoi viereisiin ruutuihin
        int[]rivit = new int[]{1,0,-1,0};
        int[]sarak = new int[]{0,1,0,-1};
        
        // Linnaa käydään läpi, kunnes jonossa ei ole enää sinne kuuluvia paloja
        while (!jono.isEmpty()) {
            // Pisteyteään jonosta otettu linna ruutu
            // Merkitään se käsitellyksi, jotta se ei menisi vahingossa takaisin
            int[]edellinen = jono.poll();
            pisteytys[edellinen[0]][edellinen[1]] = true;
            pisteet++;
                                  
            for (int i = 0; i < rivit.length; i++) {                
                // Lasketaan uudet sijainnit jonon edellisen palan perusteella
                // Algoritmi navigoi näillä ylos, alas, vasemmalle ja oikealle
                int rivi1 = edellinen[0] + rivit[i];
                int sara1 = edellinen[1] + sarak[i];    
                // Tarkistetaan, että ruutu ei ole laudan ulkopuolella
                if (voikoMenna(rivi1,sara1)) {
                    // Tarkistaan, että ruutua ei ole vielä pisteytetty
                    if (pisteytys[rivi1][sara1] == false) {
                        if (lauta[rivi1][sara1] == 2 || lauta[rivi1][sara1]==3) {
                            int[]uusi = new int[]{rivi1,sara1};
                            jono.add(uusi);
                        } 
                    }                    
                }    
            }
        }          
        return pisteet;
    }
    
    // Laskee pelaajan saamat pisteet, tässä vaiheessa pelaajia on vain yksi
    // Funktio on kuitenkin rakennettu siihen muotoon, että se voi laskea 
    // Useamman pelaajan pisteet
    // Pistelasku aloitetaan lautan yläkulmasta
    // Funktio käy koko matriisin läpi ja aloittaa yksittäisen linnan 
    // pisteytyksen heti kun löytää ruudun, joka ei ole pelto.
    public int laskePisteet() {
        int pisteet = 0;
        
        for (int i = 0; i < koko; i++) {
            for (int j = 0; j < koko; j++) {
                // Varmistetaan, että ruutua ei ole jo pisteytetty
                if (pisteytys[i][j] == false) {
                    // Jos ruutu on joutomaa(tyhjä) tai pelto
                    // merkitään ruutu käsitellyksi ja siirrytään eteenpäin
                    if (lauta[i][j] == 1 || lauta[i][j] == 0) {
                        pisteytys[i][j] = true;
                    // Jos kyseessä on linna, siirrytään pisteyttämään linnaa    
                    } else {
                        pisteet = pisteet + linnanPisteet(i,j); 
                    }
                }
            }
        }        
        return pisteet;
    }
    
    // Metodi tarkistaa, että linna on kokonaan peltojen ympäröimä
    // Metodi palauttaa falsen, jos on olemassa yksikin linnaruutu,
    // joka ei ole kokonaan toisten linnojen tai peltojen ympäröimä
    // Koska samaksi linnaksi lasketaan vain linna palat, jotka ovat 
    // toisen linnapalan ylä, ala, oikealla tai vasemmalla puolella,
    // kulmittain olevista paloista ei tarvitse välittää
    public boolean onValmis(int rivi, int sarake) {
        // Käsittelemättömät ruudut ovat tässä jonossa
        // Aluksi jonoon laitetaan vain aloitusruutu
        ArrayDeque<int[]>jono = new ArrayDeque();
        int[]eka = new int[]{rivi,sarake};
        jono.add(eka);
        
        // Aputaulukko, jolla algoritmi navigoi viereisiin linna ruutuihin
        int[]rivit = new int[]{1,0,-1,0};
        int[]sarak = new int[]{0,1,0,-1};
                 
        while(jono.isEmpty()) {
            int[]edellinen = jono.poll();            
            // Tarkistetaan, että jonosta vedetty linnaruutu on ylhäältä, 
            // oikealta, vasemmalta ja alhaalta muiden ruutujen ympäröimä
            for (int i = 0; i < rivit.length; i++) {
                // lasketaan uudet koordinaatit
                int uusiRivi = edellinen[0] + rivit[i];
                int uusiSara = edellinen[1] + sarak[i];
                // Käsitellään uusi koordinaatti
                if (voikoMenna(uusiRivi,uusiSara)) {
                    // Tarkistetaan, onko joku linnaruudun ympärillä oleva
                    // ruutu tyhjä, jos on, voidaan lopettaa
                    if (lauta[uusiRivi][uusiSara]==0) {
                        return false;
                    } else if (lauta[uusiRivi][uusiSara] == 2) {
                        int[]uusi = new int[]{uusiRivi,uusiSara};
                        jono.add(uusi);
                    } else if (lauta[uusiRivi][uusiSara] == 3) {
                        int[]uusi = new int[]{uusiRivi,uusiSara};
                        jono.add(uusi);
                    }
                }           
            }            
        }
        
        // Jos ruutua, joka ei ole kokonaan ympäröity toisilla linna- tai
        // peltoruuduilla ei löydy, voidaan todeta linnan olevan valmis
        // Linnojahan ei sovi rakentaa pelloille, peasantit ei tykkää!
        // Monty Python's Holy Grail on parhautta!!!
        return true;
    }
}
